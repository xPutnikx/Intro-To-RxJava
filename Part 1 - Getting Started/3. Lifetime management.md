# Управление жизненным циклом

Главная идея Rx это то, что ты не знаешь "когда" последовательность вернет новые значения или завершится, но тем не менее ты должены контролировать ситуации, когда ты начнешь и закончишь принимать данные. Подписки могут быть связаны с выделенными ресурсами, которые ты возможно захочишь освободить после окончания последовательности, например чтобы избежать утечку памяти. Rx предоставляет полный контроль за созданной подпиской, что дает возможность достаточно просто сделать это.

## Процесс регистрации подписки

Далее представленны несколько перегруженных методов `Observable.subscribe`, которые являются реализацией одного и того же намерения - подписки

```java
Subscription 	subscribe()
Subscription 	subscribe(Action1<? super T> onNext)
Subscription 	subscribe(Action1<? super T> onNext, Action1<java.lang.Throwable> onError)
Subscription 	subscribe(Action1<? super T> onNext, Action1<java.lang.Throwable> onError, Action0 onComplete)
Subscription 	subscribe(Observer<? super T> observer)
Subscription 	subscribe(Subscriber<? super T> subscriber)
```

`subscribe()` получает события, но не выполняет никаких действий. 
В то время как перегрузка методов с одним или несколькими `Action` позволит тебе создать `Subscriber` с теми функциями, которые тебе не обходимы. Если ты не предоставишь никаких `Action`, например для onComplete, данные события просто проигнорируются.

В следующем примере, мы обрабатываем ошибку, которая приходит в последовательность.

```java
Subject<Integer, Integer> s = ReplaySubject.create();
s.subscribe(
	v -> System.out.println(v),
	e -> System.err.println(e));
s.onNext(0);
s.onError(new Exception("Oops"));
```

Вывод
```
0
java.lang.Exception: Oops
```

Если ты не предоставишь функцию, которая будет обрабатывать ошибку, `OnErrorNotImplementedException` будет *брошена* в том месте где `s.onError` был вызван, т.е. на стороне производителя ошибки. Это случается, когда производитель и получать находятся в одном месте, в таком случае мы можем использовать традиционный try-catch блок. Но в реальной системе, производитель и подписчик очень часто находятся в разных местах. Если подписчик не предоставляет интерфейс для обработки ошибок, то он никогда не узнает, что была брошена ошибка и последовательность была прекращена.

## Процесс отписывания 

Ты можешь прекратить слушать обновления прежде чем последовательность будет прекращена. Каждый метод `subscribe` возвращает объект `Subscription`, который в свою очередь имеет 2 метода:

```java
boolean isUnsubscribed()
void unsubscribe()
```

Вызов метода `unsubscribe` остановит события, которые приходят от Observer.

```java
Subject<Integer, Integer>  values = ReplaySubject.create();
Subscription subscription = values.subscribe(
    v -> System.out.println(v),
    e -> System.err.println(e),
    () -> System.out.println("Done")
);
values.onNext(0);
values.onNext(1);
subscription.unsubscribe();
values.onNext(2);
```
[Output](/tests/java/itrx/chapter1/UnsubscribingExample.java)
```
0
1
```

Отписывание одного слушателя не мешает остальным слушателям получать обновления от того же Observer.

```java
Subject<Integer, Integer>  values = ReplaySubject.create();
Subscription subscription1 = values.subscribe(
    v -> System.out.println("First: " + v)
);
Subscription subscription2 = values.subscribe(
	v -> System.out.println("Second: " + v)
);
values.onNext(0);
values.onNext(1);
subscription1.unsubscribe();
System.out.println("Unsubscribed first");
values.onNext(2);
```
[Output](/tests/java/itrx/chapter1/UnsubscribingExample.java)
```
First: 0
Second: 0
First: 1
Second: 1
Unsubscribed first
Second: 2
```

## onError and onCompleted

`onError` и `onCompleted` обозначают прерывание последовательности. Следуя правилам Rx, Observable после этих событий больше не будет отдавать никакие другие события. Это так же стоит учитывать при реализации твоих собственых observable.

```java
Subject<Integer, Integer>  values = ReplaySubject.create();
Subscription subscription1 = values.subscribe(
    v -> System.out.println("First: " + v),
    e -> System.out.println("First: " + e),
    () -> System.out.println("Completed")
);
values.onNext(0);
values.onNext(1);
values.onCompleted();
values.onNext(2);
```
[Output](/tests/java/itrx/chapter1/RxContractExample.java)
```
First: 0
First: 1
Completed
```

## Освобождение ресурсов

`Subscription` связан с ресурсами, которые он использует. По этой причине, во избежание утечек памяти, вы должны не забывать избавляться от подписки. Ты можешь создать биндинг между `Subscription` и необходимыми ресурсами используя [Subscriptions](http://reactivex.io/RxJava/javadoc/rx/subscriptions/Subscriptions.html) фабрику.

```java
Subscription s = Subscriptions.create(() -> System.out.println("Clean"));
s.unsubscribe();
```
[Output](/tests/java/itrx/chapter1/UnsubscribingExample.java)
```
Clean
```

`Subscriptions.create` принимает action который выполнится при отписывания для освобождения ресурсов. There also are shorthand for common actions when creating a sequence.
* `Subscriptions.empty()` возвращает `Subscription` которая не делает ничего, когда очищается. Этот метод может быть полезен когда необходимо вернуть экземпляр `Subscription`, но твоя реализация не нуждается в каких-либо ресурсах.
* `Subscriptions.from(Subscription... subscriptions)` возвращает `Subscription`, которая очисчит другие подписки, после очистки себя.
* `Subscriptions.unsubscribed()` возвращает `Subscription` которая уже очищена.

Далее несколько возможных имплементаций `Subscription`.

* `BooleanSubscription`
* `CompositeSubscription`
* `MultipleAssignmentSubscription`
* `RefCountSubscription`
* `SafeSubscriber`
* `Scheduler.Worker`
* `SerializedSubscriber`
* `SerialSubscription`
* `Subscriber`
* `TestSubscriber`

Большинство из них вы увидите дальше в книге. Стоит заметить что `Subscriber` так же реализует интерфейс `Subscription`. Это значит что ты можешь использовать ссылку на `Subscriber` для прекращения подписки.

#### Continue reading

| Previous | Next |
| --- | --- |
| [Key types](/Part 1 - Getting Started/2. Key types.md) | [Chapter 2](/Part 2 - Sequence Basics/1. Creating a sequence.md) |
